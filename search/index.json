[{"content":"使用命令 docker build 缓存使用\nGo项目使用缓存依赖示例，Dockerfile中使用\u0026ndash;mount\n1 2 3 4 RUN --mount=type=cache,mode=0777,id=go-mod,target=/go/pkg/mod \\ go env -w GOPROXY=https://goproxy.cn,direct \u0026amp;\u0026amp; \\ go mod tidy \u0026amp;\u0026amp; \\ go build -o main ","date":"2023-07-26T00:00:00Z","permalink":"https://bllon.github.io/p/docker-build-cache/","title":"docker build缓存依赖项"},{"content":"anaconda官网下载地址 官网地址\n直接下一步安装即可\n配置环境变量 1 2 3 4 5 D:\\ProgramData\\anaconda3 D:\\ProgramData\\anaconda3\\Scripts D:\\ProgramData\\anaconda3\\Library\\mingw-w64\\bin D:\\ProgramData\\anaconda3\\Library\\usr\\bin D:\\ProgramData\\anaconda3\\Library\\bin 1 2 3 4 5 6 7 8 9 10 11 查看python版本 python 查看conda版本 conda --version 查看环境 conda info conda info -e conda env list conda info --envs 创建虚拟环境 1 2 3 4 5 6 7 8 9 10 conda create --name env python=3.9.0 切换环境 conda activate env 退出环境 conda deactivate 删除环境 conda remove -n env --all PowerShell无法切换环境 1 2 3 4 5 6 7 8 允许本地脚本 Set-ExecutionPolicy RemoteSigned 重置conda环境 conda init powershell 重新打开窗口 conda env list ","date":"2023-07-22T00:00:00Z","permalink":"https://bllon.github.io/p/anaconda-install/","title":"Anaconda安装"},{"content":"介绍 Ed25519是一个公钥签名系统。 快速单签名验证，该软件只需要273364个周期来验证英特尔广泛部署的Nehalem/Westmere系列cpu上的签名。(此性能测量是针对短消息的;对于非常长的消息，验证时间主要由哈希时间决定。)Nehalem和Westmere包括2008年至2010年间发布的所有酷睿i7、i5和i3 cpu，以及同一时期发布的大部分至强cpu。 甚至更快的批量验证，该软件执行一批64个单独的签名验证(在64个公钥下验证64个消息的64个签名)，仅855万次循环，即每个签名在134000次循环以下。该软件很容易适应L1缓存，因此内核之间的争用可以忽略:四核2.4GHz的Westmere每秒验证71000个签名，同时将最大验证延迟保持在4毫秒以下。 非常快的签名，该软件只需要87548个周期来签署消息。四核2.4GHz韦斯特米尔每秒可签署109000条消息。 快速生成密钥，密钥生成几乎和签名一样快。为了从操作系统获得安全的随机数，生成密钥会有轻微的代价;Linux下的/dev/urandom大约需要6000个循环。 安全级别高，该系统的安全目标为2^128;破解它的难度与破解NIST P-256、拥有3000位密钥的RSA、强128位分组密码等类似。已知的最佳攻击实际上平均花费超过2^140位操作，并且随着位操作数量的下降，成功概率呈二次下降。 万无一失的会话密钥。确定地生成签名;密钥生成需要新的随机性，但新签名不需要。这不仅是一个速度特性，也是一个安全特性，与最近索尼PlayStation 3安全系统崩溃直接相关。\nED25519是一个非对称加密的签名方法，非常快、非常安全、产生的数据也非常小。\nED25519的签名长度，公钥长度是多少？ 签名长度为64字节，公钥长度为32字节\n什么是数字签名？ 数字签名（又称公钥数字签名）是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。 是用于鉴别数字信息的方法，有签名并有验证。数字签名是非对称密钥加密技术（如ED25519）与数字摘要技术的应用。 数字签名就是附加在数据单元上的一些数据，或者是针对数据所做出的一种密码变换。这种数据或变换允许数据单元的接收者用以确认数据单元的来源和数据单元的完整性并保护数据，即数字签名与验证同在。\n数字签名的级别？ 数字签名的级别是很高的，是具备不可否定性的。\n数字签名大致有哪些算法？ RSA、ElGamal、Fiat-Shamir、Guillou- Quisquarter、Schnorr、Ong-Schnorr-Shamir数字签名算法、Des/DSA，椭圆曲线数字签名算法和有限自动机数字签名算法等。特殊数字签名有盲签名、代理签名、群签名、不可否认签名、公平盲签名、门限签名、具有消息恢复功能的签名等。 目前用到的是“椭圆曲线数字签名（ECDSA）”。\n什么是“椭圆曲线数字签名(ECDSA)”？ 简称ECC算法，是基于数学理论的椭圆曲线来实现的一种“非对称加密”算法。\nECC的特点？ 密钥的长度很短，高安全。\n在数学理论中什么是“椭圆曲线”？ 椭圆曲线指，在特定条件下的特定点的集合所形成的规律（即椭圆曲线公式）。\n数字签名特点？ 每条信息都有一对密钥，其中一个是信息自身的密钥，另一个是公开的公钥。 在信息或者数据开始签名时用的是密钥，在进入验证时用的是公钥。 在验证时公钥是公用的，那如何进行准确识别每条信息或数据？ 所有信息都可以被定义，所以公钥需要先向接收端进行注册（身份认证机构），这时就产生了“注册机”，在注册后身份认证机构会写入一串数字证书，然后在对信息签名时，会将数字证书和签名绑定到信息上一起发送到接收端，接收端会向身份认证机构确认密钥的正确性，从而判断密钥和信息是否匹配。\n签名过程是什么？ 发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要，然后用发送方的私钥对这个摘要进行加密，这个加密后的摘要将作为报文的数字签名和报文一起发送给接收方，接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再公钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认该报文是发送方的。\n什么是哈希函数？ 哈希函数（Hash Function），也称为散列函数，给定一个输入x，它会算出相应的输出H(x)。\n哈希函数的算法特点是什么？ 1.输入x可以是任意长度的字符串。 2.输出结果即H(x)的长度是固定的。 3.计算 H(x) 的过程是高效的（对于长度为 n 的字符串 x ，计算出 H(x) 的时间复杂度应为 O(n) ）。\n哈希函数在运用时有什么要求？ 1、免碰撞：即不会出现输入 x≠y ，但是H(x)=H(y) 的情况，其实这个特点在理论上并不成立，比如目前比特币使用的 SHA256 算法，会有 2^256 种输出，如果我们进行 2^256 + 1 次输入，那么必然会产生一次碰撞，事实上，通过 理论证明 ，通过 2^130 次输入就会有99%的可能性发生一次碰撞。 2、隐匿性：对于一个给定的输出结果 H(x) ，想要逆推出输入 x ，在计算上是不可能的。如果想要得到 H(x) 的可能的原输入，不存在比穷举更好的方法。\n哈希算法的原理是什么？ 是试图将一个空间的数据集映射到另外一个空间（通常比原空间要小），并利用质数将数据集能够均匀的映射。\n目前有哪些哈希算法？ md4、md5、sha系列等。\n使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 import nacl from \u0026#34;tweetnacl\u0026#34; //string和uint8Array互转 //https://cloud.tencent.com/developer/ask/sof/302640 //base64和uint8Array互转 //https://blog.csdn.net/qq_35606400/article/details/125629074 // uint8array转为base64字符串 const uint8arrayToBase64 = function(u8Arr) { try{ let CHUNK_SIZE = 0x8000; //arbitrary number let index = 0; let length = u8Arr.length; let result = \u0026#39;\u0026#39;; let slice; while (index \u0026lt; length) { slice = u8Arr.subarray(index, Math.min(index + CHUNK_SIZE, length)); result += String.fromCharCode.apply(null, slice); index += CHUNK_SIZE; } // web image base64图片格式: \u0026#34;data:image/png;base64,\u0026#34; + b64encoded; // return \u0026#34;data:image/png;base64,\u0026#34; + btoa(result); return btoa(result); } catch(e) { throw e; } } // base64字符串转为uint8array数组 const base64ToUint8Array = function(base64String) { try{ let padding = \u0026#39;=\u0026#39;.repeat((4 - base64String.length % 4) % 4); let base64 = (base64String + padding) .replace(/\\-/g, \u0026#39;+\u0026#39;) .replace(/_/g, \u0026#39;/\u0026#39;); let rawData = atob(base64); let outputArray = new Uint8Array(rawData.length); for (let i = 0; i \u0026lt; rawData.length; ++i) { outputArray[i] = rawData.charCodeAt(i); } return outputArray; } catch(e) { throw e; } } // string转uint8array function toUint8Arr(str) { const buffer = [] for (let i of str) { const _code = i.charCodeAt(0) if (_code \u0026lt; 0x80) { buffer.push(_code) } else if (_code \u0026lt; 0x800) { buffer.push(0xc0 + (_code \u0026gt;\u0026gt; 6)) buffer.push(0x80 + (_code \u0026amp; 0x3f)) } else if (_code \u0026lt; 0x10000) { buffer.push(0xe0 + (_code \u0026gt;\u0026gt; 12)) buffer.push(0x80 + (_code \u0026gt;\u0026gt; 6 \u0026amp; 0x3f)) buffer.push(0x80 + (_code \u0026amp; 0x3f)) } } return Uint8Array.from(buffer) } /** * 使用tweetnacl进行签名 * signContent 签名内容 */ function tweetnaclSign(signContent) { // 生成 公钥、私钥 // let keyMap = nacl.sign.keyPair() // let publicKey = keyMap.publicKey // let secretKey = keyMap.secretKey console.log(\u0026#34;待签名内容: \u0026#34;, signContent) console.log(\u0026#34;用户服务端的公钥和私钥\u0026#34;) let publicKey = base64ToUint8Array(\u0026#34;BXJXQSSIuVCdHU7FUj/e4McA6MHVP0t7AR9tQg4GyF0=\u0026#34;) let secretKey = base64ToUint8Array(\u0026#34;ZBsmNTR/pwQDSKX261V5g+7zgpfXY9ejRvLDPiK4GXwFcldBJIi5UJ0dTsVSP97gxwDowdU/S3sBH21CDgbIXQ==\u0026#34;) // 字符串转为Uint8Array格式，以供签名 let signArray = toUint8Arr(signContent) // 进行签名 let signature = nacl.sign.detached(signArray, secretKey) // 进行验签 let verify = nacl.sign.detached.verify(signArray, signature, publicKey) console.log({ \u0026#39;公钥\u0026#39;: uint8arrayToBase64(publicKey), \u0026#39;私钥\u0026#39;: uint8arrayToBase64(secretKey), \u0026#39;签名\u0026#39;: uint8arrayToBase64(signature), \u0026#39;验签成功\u0026#39;: verify }) } let msgData = \u0026#39;哈哈哈哈\u0026#39; tweetnaclSign(msgData) ","date":"2023-07-22T00:00:00Z","permalink":"https://bllon.github.io/p/ed25519/","title":"ed25519加密算法使用"},{"content":"介绍 Git（读音为/gɪt/）是一个开源的分布式版本控制系统， 可以有效、高速地处理从很小到非常大的项目版本管理。 [1]也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。\n可以理解为一个本地的文件仓库， 你可以创建一个仓库， 然后管理里面的文件（修改，添加，删除）， 每次提交都会产生一个版本， 假如你突然想回到之前的某一个版本， 可以通过git命令进行回退到之前的修改。 也可以多个人协作去管理一个仓库。\n下载安装Git 官网下载地址，直接下载最新版本即可\n接着点击下载的安装包，选择安装路径，一直下一步直到安装完成。\n验证安装： 在命令行输入git version 得到输出的git版本信息即代表安装成功\n使用Git 配置git用户信息\n1 2 git config --global user.name=“用户名” git config --global user.email=“邮箱” 创建一个文件夹（作为我们要管理的仓库） 初始化git仓库 cmd进入命令行, 在该目录下执行 git init 命令进行初始化仓库 接着我们可以在仓库目录下进行文件的添加，修改，删除 使用 git status 命令查看当前仓库的状态，发现红色的文件名，为我们新增的文件 使用 git add . 命令将发生改变的文件提交到暂存库中，可以理解为一个编辑修改的区域 使用 git status 命令查看当前仓库的状态，发现绿色的文件名，为我们已添加到暂存库中的文件 使用 git commit 命令提交一个版本 使用 git log 命令查看我们提交的版本记录 使用 git reset \u0026ndash;hard [版本号] 命令可以回退到某个版本 具体操作如下：\n创建一个myblog文件下，命令行进入该目录\ngit还有其他很多命令，可以参考学习 Git菜鸟教程\nGithub注册使用 Github可以理解为一个远程的仓库，我们可以把本地仓库和远程仓库关联起来， 进而每次提交版本都可以将文件推送到远程仓库，也可以将远程仓库下载到本地\n注册 在 Github网站 注册一个账号，点击Sign up一般使用邮箱注册即可，\n注册完点击Sign in登录\n点击右上角头像，点击Your repositories进入自己的仓库列表页面， 点击New新建一个远程仓库，只需要填写仓库的名字即可\n我这里创建一个test的仓库\n提交到远程仓库 由于我们前面仓库已经建好了，所以不需要前面的git init等初始化操作\n第一次提交需要登录远程仓库，需要使用Github的邮箱账号密码，\n或者使用Token （个人头像下的Settings中，Developer Settings下Personal access tokens (classic)，New一个新的token， 只需要勾选repo和workflow权限即可）\n依次执行\n1 2 3 git remote add origin https://github.com/bllon/test.git git push -u origin master 再此刷新远程仓库页面，即可看到我们的仓库文件\n","date":"2023-07-22T00:00:00Z","permalink":"https://bllon.github.io/p/git-install/","title":"Git安装和使用"},{"content":"解决 找到go包的src目录下的syscall/types_windows.go文件 修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 var signals = [...]string{ 1: \u0026#34;hangup\u0026#34;, 2: \u0026#34;interrupt\u0026#34;, 3: \u0026#34;quit\u0026#34;, 4: \u0026#34;illegal instruction\u0026#34;, 5: \u0026#34;trace/breakpoint trap\u0026#34;, 6: \u0026#34;aborted\u0026#34;, 7: \u0026#34;bus error\u0026#34;, 8: \u0026#34;floating point exception\u0026#34;, 9: \u0026#34;killed\u0026#34;, 10: \u0026#34;user defined signal 1\u0026#34;, 11: \u0026#34;segmentation fault\u0026#34;, 12: \u0026#34;user defined signal 2\u0026#34;, 13: \u0026#34;broken pipe\u0026#34;, 14: \u0026#34;alarm clock\u0026#34;, 15: \u0026#34;terminated\u0026#34;, /** 兼容windows start */ 16: \u0026#34;SIGUSR1\u0026#34;, 17: \u0026#34;SIGUSR2\u0026#34;, 18: \u0026#34;SIGTSTP\u0026#34;, /** 兼容windows end */ } /** 兼容windows start */ func Kill(...interface{}) { return } const ( SIGUSR1 = Signal(0x10) SIGUSR2 = Signal(0x11) SIGTSTP = Signal(0x12) ) /** 兼容windows end */ ","date":"2023-07-22T00:00:00Z","permalink":"https://bllon.github.io/p/go-windows-syscall-sigusr1/","title":"go 报错undefined syscall.SIGUSR1"},{"content":"介绍 官方下载文档\nHugo中文文档\nHugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\n下载 以下两种方式，任选其中一种。当然官方也提供了其他方式，执行对应的命令即可。\n对于开发者，可以选择源代码构建方式，前提是需要安装Git和Go以及gcc编译器，这些我在其他文章都有介绍 1 go install -tags extended github.com/gohugoio/hugo@latest 对于新手小白或者只想简单的搞一个博客，推荐使用winget安装方式，这是微软自带的免费的包管理器 1 winget install Hugo.Hugo.Extended 选择博客主题模板 我选的是这款 Stack\nGithub地址\n运行 将上方的Github仓库下载下来 解压，然后把文件夹改成你想要的名字 cmd进入命令行，进到该目录下，输入hugo server回车，服务就会启动，给出对应的博客地址：http://localhost:1313/ 浏览器进入博客网站 至此博客基本搭建完成\n网站配置 所有的配置文件都在config/_default目录下，我们在修改内容的同时，网站会实时进行更新\n修改网站标题 config.toml 修改菜单 menu.toml\n我们可以在 阿里图标库 下载我们喜欢的图标，svg格式，我是用的是128大小，070707颜色 修改副标题 params.toml 新建文章 在content/post目录下，每个文件夹对应一篇文章，新建index.md（也可以通过hugo命令方式创建），里面就是写文章的配置和内容，我们可以参考示例文章进行更改\n更多配置 更多详细的配置，可以去看作者的官方文档 Stack\n里面包括 自定义页头页脚html内容， 开启评论， 嵌入视频， 图片等等\n发布Github 在命令行博客目录下输入hugo，即可生成public目录，里面就是编译生成好的静态博客目录，只需要将该目录和远程仓库绑定即可\n在Github分类下有一篇文章介绍创建远程仓库及使用git推送， 只需要创建一个bllon.github.io名称的仓库即可， bllon是我的名称，可以随意起名\n接着我们在仓库设置下的Page下使用们的分支即可 浏览器输入bllon.github.io即可访问我们的博客页面\n配置Github Actions自动部署 我们将博客目录作为一个推送仓库，每次提交到这个仓库，github的actions就会自动触发任务， 将自动编译得到public目录并推送到另一个仓库bllon.github.io\n只需要改动.github/workflows目录下的deploy.yml文件\n在项目仓库下的settings中创建 PERSONAL_TOKEN 环境变量 在xx.github.io项目的settings下的actions/general下 需要勾选权限： Allow all aactions and reusable workflows Require approval for first-time contributors Read and write permissions或者第二个\ntoken需要权限：gist, read:org, repo, workflow\n在项目仓库下的Actions中可以查看部署的任务，每次push提交远程仓库可以自动触发，也可以在GitHub仓库页面去执行和管理 至此完整的hugo博客搭建流程完毕！\n","date":"2023-07-22T00:00:00Z","permalink":"https://bllon.github.io/p/hugo-blog/","title":"Hugo博客搭建"},{"content":"介绍 MinGW，是Minimalist GNU for Windows的缩写。 它是一个可自由使用和自由发布的Windows特定头文件和使用GNU工具集导入库的集合， 允许你在GNU/Linux和Windows平台生成本地的Windows程序而不需要第三方C运行时（C Runtime）库。 MinGW 是一组包含文件和端口库，其功能是允许控制台模式的程序使用微软的标准C运行时（C Runtime）库（MSVCRT.DLL）, 该库在所有的 NT OS 上有效，在所有的 Windows 95发行版以上的 Windows OS 有效， 使用基本运行时，你可以使用 GCC 写控制台模式的符合美国标准化组织（ANSI）程序， 可以使用微软提供的 C 运行时（C Runtime）扩展，与基本运行时相结合， 就可以有充分的权利既使用 CRT（C Runtime）又使用 WindowsAPI功能。\n下载安装 下载地址\n选择一个版本, 例如 MinGW-W64 GCC-8.1.0\n1 2 64位下载 x86_64-posix-seh 32位下载 x86_64-win32-seh 点击对应链接等待5秒下载, 下载后解压里面会包含一个mingw64的目录, 只需要保留该目录即可\n接着配置环境变量, 将mingw64/bin目录添加到系统变量的Path变量中\n验证安装 cmd打开一个命令行窗口, 输入gcc -v 得到gcc的版本信息即安装成功\n","date":"2023-07-22T00:00:00Z","permalink":"https://bllon.github.io/p/mingw-install/","title":"MinGW安装（gcc）"},{"content":"nvm下载地址 下载地址\n选择nvm-setup.exe\n选择目录和nodejs环境目录直接下载\n查看版本\n1 nvm version 安装nodejs 安装指定版本node 1 nvm install 16.18.0 切换指定版本node 1 nvm use 16.18.0 查看已安装的node列表 1 nvm list 卸载指定版本node 1 nvm uninstall 16.18.0 ","date":"2023-07-22T00:00:00Z","permalink":"https://bllon.github.io/p/nvm-install/","title":"nvm安装"},{"content":"下载地址 下载地址\n解压配置环境变量\nmac下安装 https://www.jianshu.com/p/4b9b042e812e\n","date":"2023-07-22T00:00:00Z","permalink":"https://bllon.github.io/p/protobuf-install/","title":"Protobuf安装"},{"content":"Windows下安装 下载Go语言sdk sdk下载地址 , 找到stable version版本, 目前已经更新到1.20.6\nwindows系统64位下载windows-amd64.zip, 32位下载windows-386.zip, 一般都是64位\n下载完解压到一个go的目录下\n配置环境变量 打开windows文件管理器, 鼠标右键点击此电脑, 点击属性, 点击高级系统设置进入系统属性, 点击环境变量\n新建系统变量\n1 2 3 GOROOT =\u0026gt; go的sdk解压存放目录（例如D:/go） GOPATH =\u0026gt; 新建go的项目目录（例如D:/project/go） 找到系统变量中的Path, 双击进入, 新建\n%GOROOT%\\bin\n%GOPATH%\\bin\n验证安装 win + R 组合键, 输入cmd进入命令行, 输入go version, 输出得到go version go1.20.6 windows/amd64, 即代表安装成功\n配置go的代理环境 继续在命令行终端里输入并回车\n1 2 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 至此windows下的Go环境安装完毕\nLinux下安装 下载Go语言sdk sdk下载地址 , 找到stable version版本, 目前已经更新到1.20.6\nlinux系统64位下载linux-amd64.tar.gz, 32位下载linux-386.tar.gz, 一般都是64位, 鼠标右键可以复制对应链接\n下载完解压到一个go的目录下\n1 2 3 4 5 #下载 wget https://golang.google.cn/dl/go1.20.6.linux-amd64.tar.gz #解压 tar -xzvf go1.20.6.linux-amd64.tar.gz 配置环境变量 修改环境变量文件\n1 vim /etc/profile 在最后一行添加\n1 2 3 export GOROOT=/usr/local/go //GOROOT为解压的go sdk目录 export PATH=$PATH:$GOROOT/bin 保存文件, 执行source /etc/profile使环境变量生效\n验证安装 直接在终端输入go version, 输出得到go version go1.20.6 linux/amd64, 即代表安装成功\n配置go的代理环境 继续在命令行终端里输入并回车\n1 2 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 至此linux下的Go环境安装完毕\n","date":"2023-07-21T00:00:00Z","permalink":"https://bllon.github.io/p/go-install/","title":"Go环境安装"},{"content":"欢迎来到我的GitHub个人页面, 我将在这里分享我所有的编程创作历程和学习经验, 请为我点亮star, 让我们一起成为更好的开发者!\n","date":"2023-07-20T00:00:00Z","image":"https://bllon.github.io/p/hello/hello_hu2fd2dc316cdfeaad67b0b4fc90742247_78830_120x120_fill_q75_box_smart1.jpg","permalink":"https://bllon.github.io/p/hello/","title":"开启新篇章"}]